# üê£ S1 | Prog: Workshop (Solution)

- [üìÖ Planning](#-planning)
  - [Lundi](#lundi)
    - [Prof](#prof)
    - [√âl√®ve](#√©l√®ve)
  - [Mardi](#mardi)
    - [Matin](#matin)
      - [Prof](#prof-1)
      - [√âl√®ve](#√©l√®ve-1)
    - [Apr√®m](#apr√®m)
      - [Prof](#prof-2)
      - [√âl√®ve](#√©l√®ve-2)
  - [Mercredi](#mercredi)
    - [Prof](#prof-3)
    - [√âl√®ve](#√©l√®ve-3)
  - [Jeudi](#jeudi)
    - [Prof](#prof-4)
    - [√âl√®ve](#√©l√®ve-4)
  - [Vendredi](#vendredi)
    - [Matin](#matin-1)
      - [Prof](#prof-5)
      - [√âl√®ve](#√©l√®ve-5)
    - [Apr√®m](#apr√®m-1)
- [üíª Exercices](#-exercices)
  - [‚≠ê Noir \& Blanc](#-noir--blanc)
  - [‚≠ê Channels swap](#-channels-swap)
  - [‚≠ê‚≠ê Conversions RGB ‚áî HSL](#-conversions-rgb--hsl)
    - [‚≠ê Hue shift](#-hue-shift)
    - [‚≠ê D√©saturation](#-d√©saturation)
    - [‚≠ê Assombrissement / √âclaircissement](#-assombrissement--√©claircissement)
  - [‚≠ê‚≠ê Contraste](#-contraste)
  - [‚≠ê‚≠ê Luminosit√©](#-luminosit√©)
  - [‚≠ê‚≠ê Miroir](#-miroir)
  - [‚≠ê‚≠ê Color glitch](#-color-glitch)
  - [‚≠ê‚≠ê‚≠ê Position glitch](#-position-glitch)
  - [‚≠ê‚≠ê‚≠ê Vortex](#-vortex)
  - [‚≠ê‚≠ê RGB split](#-rgb-split)
  - [‚≠ê‚≠ê Dessiner un disque](#-dessiner-un-disque)
    - [‚≠ê Dessiner un cercle](#-dessiner-un-cercle)
    - [‚≠ê‚≠ê Dessiner une rosace](#-dessiner-une-rosace)
  - [‚≠ê‚≠ê‚≠ê Dessiner la fractale de Mandelbrot](#-dessiner-la-fractale-de-mandelbrot)
  - [‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image](#-k-means--trouver-les-couleurs-les-plus-pr√©sentes-dans-une-image)
  - [‚≠ê‚≠ê‚≠ê Convolutions](#-convolutions)
    - [‚≠ê‚≠ê Flou gaussien](#-flou-gaussien)
    - [‚≠ê‚≠ê Difference of gaussians](#-difference-of-gaussians)
    - [‚≠ê‚≠ê‚≠ê Histogram Equalization](#-histogram-equalization)
    - [‚≠ê‚≠ê‚≠ê Affichage de l'histogramme](#-affichage-de-lhistogramme)
  - [‚≠ê‚≠ê Effet S√©pia](#-effet-s√©pia)
  - [Feel free to implement your own effects!](#feel-free-to-implement-your-own-effects)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Kuwahara filter](#-kuwahara-filter)
  - [‚≠ê‚≠ê‚≠ê Color palette dithering](#-color-palette-dithering)
  - [‚≠ê‚≠ê‚≠ê Spatial dithering](#-spatial-dithering)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Pixel sorting](#-pixel-sorting)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square](#-diamond-square)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Flood Fill](#-flood-fill)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Canny Edge Detection](#-canny-edge-detection)
  - [‚≠ê‚≠ê Mosaic](#-mosaic)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ray Tracing](#-ray-tracing)
- [Rendu](#rendu)
  - [Exercices √† faire](#exercices-√†-faire)
  - [Rapport](#rapport)
  - [Soutenance](#soutenance)


## üìÖ Planning

### Lundi

#### Prof

- [ ] Pr√©sentation du projet
- [ ] Pr√©sentation de la lib

#### √âl√®ve

- [ ] Cr√©ation du groupe : bin√¥me obligatoirement (et 1 trin√¥me dans la classe si impair)
- [ ] Prise en main de la lib
- [ ] Quelques exercices de niveau 1 (‚≠ê), et 2 (‚≠ê‚≠ê) si vous vous sentez chaud

### Mardi

#### Matin

##### Prof

- [ ] Pr√©sentation de git

##### √âl√®ve

- [ ] Cr√©ation du git
- [ ] Test et prise en main de git (l'un push quelque chose et l'autre le pull par exemple)
- [ ] Mettre sur le repository les exercices que vous avez fait hier

#### Apr√®m

##### Prof

- [ ] Pr√©sentation des algos avanc√©s (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê)
- [ ] Conseil : faites un fichier √† part pour votre algo avanc√©, car il y aura probablement plusieurs fonctions interm√©diaires √† √©crire, et peut-√™tre des structs aussi.

##### √âl√®ve

- [ ] Choix de l'algo que vous allez impl√©menter (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê)
- [ ] Commencer √† vous renseigner sur votre algo avanc√©, √† l'impl√©menter

### Mercredi

#### Prof

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes, regarder l'algo avanc√© qu'iels ont choisi.


#### √âl√®ve

- [ ] Avancer sur l'algo avanc√©

### Jeudi

#### Prof

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes et d√©cider qui pr√©sente quel algo. Possibilit√© que plusieurs groupes se mettent ensemble pour pr√©senter leur algo si tout le monde a envie de passer.

#### √âl√®ve

- [ ] Finir votre algo avanc√©


### Vendredi

#### Matin

##### Prof

- [ ] Pr√©sentation de Markdown pour l'√©criture du rapport
  - [ ] Extension VSCode, et comment elle permet de g√©n√©rer une Table of Content
  - [ ] Syntaxe basique (titres, gras, italique), et si voulez vous pouvez aller voir comment [le document que vous √™tes en train de lire](TODO mettre le lien du sujet qui est sur le git) est √©crit, c'est du markdown !
  - [ ] Mettre des images (s'assurer du coup que leur dossier output soit √† la racine du repo, et soit commit)

##### √âl√®ve

- [ ] √âcriture du rapport. (Vous avez jusqu'√† lundi matin pour les rendre).
- [ ] Pr√©paration de la pr√©sentation pour celleux concern√©.e.s

#### Apr√®m

- [ ] Pr√©sentations


## üíª Exercices

- Leur dire de travailler sur une image pas trop grande, pour que le rendu soit quasi-instantan√©. (Par exemple l'image par d√©faut fournie dans le projet est tr√®s bien).
- Leur dire d'afficher l'image output √† c√¥t√© dans VSCode pour facilement voir le r√©sultat
![Alt text](image.png)

### ‚≠ê Noir & Blanc

N'h√©sitez pas √† **aller chercher la formule sur internet** si besoin !

### ‚≠ê Channels swap

![](output/channels_swap.png)

Par exemple, √©changez le canal rouge et le canal bleu.

### ‚≠ê‚≠ê Conversions RGB ‚áî HSL

Vous pouvez reprendre les formules RGB ‚Üí HSL et HSL ‚Üí RGB [depuis cette page](https://www.easyrgb.com/en/math.php). Attention, iels consid√®rent que R, G et B vont entre 0 et 255, alors que pour nous ils vont de 0 √† 1. Il faudra donc l√©g√®rement adapter les formules du site.

En elles-m√™mes ces formules ne changent pas l'image, mais elles vous permettent d'impl√©menter facilement les effets suivants:

#### ‚≠ê Hue shift
#### ‚≠ê D√©saturation
#### ‚≠ê Assombrissement / √âclaircissement

### ‚≠ê‚≠ê Contraste

### ‚≠ê‚≠ê Luminosit√©

### ‚≠ê‚≠ê Miroir

![](output/miroir.png)

Sym√©trie par rapport √† l'axe Y (vertical).

### ‚≠ê‚≠ê Color glitch

Remplacer quelques pixel au hasard par une couleur al√©atoire.

### ‚≠ê‚≠ê‚≠ê Position glitch

![](output/position_glitch.png)

Prendre un rectangle de pixels et l'intervertir avec un autre rectangle de pixels, ailleurs dans l'image. Faire √ßa plusieurs fois.

### ‚≠ê‚≠ê‚≠ê Vortex

![](output/vortex.png)

### ‚≠ê‚≠ê RGB split

![](output/rgb_split.png)

‚ö†Ô∏è Cr√©ez une nouvelle image et travaillez sur celle-ci. Il ne faut pas modifier l'image originale pendant que vous bouclez pour appliquer l'effet, sinon certains pixels n'utiliseront pas la bonne couleur de l'image originale, mais plut√¥t la couleur d√©j√† modifi√©e par un pixel pr√©c√©dent, ce qui pourrait vous donner ce genre de rendu moins int√©ressant :

![](output/rgb_split_incorrect.png)

### ‚≠ê‚≠ê Dessiner un disque

Vous pouvez cr√©er une image noire avec
```cpp
sil::Image image{500/*width*/, 500/*height*/};
```

Ensuite, √† vous de parcourir les pixels et de les colorier ou non en fonction de si ils sont √† l'int√©rieur du cercle.

#### ‚≠ê Dessiner un cercle

En reprenant et modifiant l√©g√®rement votre code pour le disque, √©crivez le code qui donne un cercle. (Son contour aura une √©paisseur donn√©e `thickness`).

#### ‚≠ê‚≠ê Dessiner une rosace

Maintenant que vous savez dessiner un cercle, dessinez-en plusieurs sur la m√™me image, √† des positions diff√©rentes, de sorte √† dessiner une rosace.

### ‚≠ê‚≠ê‚≠ê Dessiner la fractale de Mandelbrot



### ‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image

Trouvez les k couleurs les plus repr√©sentatives de l'image, puis assignez √† chaque pixel la couleur dont il est le plus proche parmi les k.

Voici une bonne vid√©o expliquant l'algorithme :

[![k-means video](https://img.youtube.com/vi/yR7k19YBqiw/0.jpg)](https://www.youtube.com/watch?v=yR7k19YBqiw)

### ‚≠ê‚≠ê‚≠ê Convolutions

#### ‚≠ê‚≠ê Flou gaussien

#### ‚≠ê‚≠ê Difference of gaussians

https://youtu.be/5EuYKEvugLU

#### ‚≠ê‚≠ê‚≠ê Histogram Equalization

Am√©lioration du contraste, en calculant la luminosit√© min et max, et en appliquant une transformation qui va mapper le plus sombre √† 0 et le plus clair √† 1.
(PS: ne testez pas avec l'image imac, le rendu ne sera pas int√©ressant, prenez plut√¥t une photo peu contrast√©e (TODO: leur donner une image test))

#### ‚≠ê‚≠ê‚≠ê Affichage de l'histogramme

S'inspirer de Lightroom. Potentiellement split les histogrammes R, G et B

### ‚≠ê‚≠ê Effet S√©pia

### Feel free to implement your own effects!

### ‚≠ê‚≠ê‚≠ê‚≠ê Kuwahara filter

https://youtu.be/LDhN-JK3U9g

(Juste la version simple, qui est expliqu√©e √† 3:11, suffit. Si vous voulez aller plus loin, vous √™tes les bienvenu.es bien s√ªr üòâ)

### ‚≠ê‚≠ê‚≠ê Color palette dithering

https://youtu.be/8wOUe32Pt-E

### ‚≠ê‚≠ê‚≠ê Spatial dithering

### ‚≠ê‚≠ê‚≠ê‚≠ê Pixel sorting

![](output/pixel_sorting.png)

Voici une bonne vid√©o expliquant l'algorithme (vous pouvez ignorer le d√©but sp√©cifique √† Processing o√π on voit comment afficher l'image) :

[![pixel sorting video](https://img.youtube.com/vi/JUDYkxU6J0o/0.jpg)](https://www.youtube.com/watch?v=JUDYkxU6J0o)

Ensuite, au lieu de trier tous les pixels de l'image, triez par colonne (ou par ligne), pour un effet plus joli.

Pour trier un tableau, vous pouvez utiliser [`std::sort`](https://www.geeksforgeeks.org/sort-c-stl/).

### ‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square

https://youtu.be/4GuAV1PnurU

### ‚≠ê‚≠ê‚≠ê‚≠ê Flood Fill

### ‚≠ê‚≠ê‚≠ê‚≠ê Canny Edge Detection

### ‚≠ê‚≠ê Mosaic

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ray Tracing

A minima une sph√®re et un shading basique.

Pour calculer le shading pour une sph√®re :
```cpp
glm::vec3 const light_direction = glm::normalize(glm::vec3{1.f, 3.f, 10.f});
glm::vec3 const light_color = glm::vec3(1.f, 1.f, 0.f);   // Yellow for the sun
glm::vec3 const ambient_color = glm::vec3(0.f, 0.f, 1.f); // Slight blue for the sky

glm::vec3 const normal = glm::normalize(intersection_point_with_the_sphere - center_of_the_sphere); // Attention cette formule ne marche que parce que c'est une sph√®re!
float const light_intensity = std::clamp(glm::dot(light_direction, normal), 0.f, 1.f);
glm::vec3 const final_color = ambient_color + light_intensity * light_color;
```

Voici une bonne vid√©o expliquant les maths dont vous aurez besoin :

[![raytracing video](https://img.youtube.com/vi/4NshnkzOdI0/0.jpg)](https://www.youtube.com/watch?v=4NshnkzOdI0)

## Rendu

### Exercices √† faire

Faites un maximum de chose, et au minimum un exercice de niveau 3 ou plus (‚≠ê‚≠ê‚≠ê).

### Rapport

A faire en Markdown obligatoirement (si vous ne connaissez pas c'est l'occasion de d√©couvrir, c'est super utile).

Faite une section par exercice que vous avez fait. Montrez une image avant et apr√®s application de l'effet (comme c'est fait dans l'√©nonc√© des exercices). Si vous jugez cela utile, vous pouvez mettre un petit texte expliquant des sp√©cificit√©s de l'algo que vous avez impl√©ment√©. (C'est surtout int√©ressant si vous avez fait des algos qui ne sont pas list√©s dans le sujet).

### Soutenance

Pr√©sentez un des algos avanc√©s que vous avez fait, en 5 minutes. C'est de la vulgarisation, il faut que tous vos camarades puissent comprend, au moins dans les grandes lignes.

> Est-ce que c'est utile ? Ca prend pas mal de temps. Mais de l'autre c√¥t√© c'est un bon exercice qui force √† avoir bien compris l'algo, et √ßa permet aux autres de voir les algos qu'iels n'ont pas impl√©ment√©. Ou sinon, je demande juste aux groupes les plus chauds de faire une pr√©sentation, comme √ßa c'est pas trop long, et on voit juste une fois chaque algo. Et on peut prendre + de temps pour chaque pr√©sentation (m√™me pas besoin de limiter le temps, iels font comme bon leur semble).
