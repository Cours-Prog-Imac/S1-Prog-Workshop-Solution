# üê£ S1 | Prog: Workshop (Solution)

- [üìÖ Planning](#-planning)
  - [Lundi](#lundi)
    - [Prof 9h30-12h45 (pause 11h00-11h15)](#prof-9h30-12h45-pause-11h00-11h15)
    - [√âl√®ve](#√©l√®ve)
  - [Mardi](#mardi)
    - [Matin 9h30-12h45 (pause 11h00-11h15)](#matin-9h30-12h45-pause-11h00-11h15)
      - [Prof](#prof)
      - [√âl√®ve](#√©l√®ve-1)
    - [Apr√®m](#apr√®m)
      - [Prof 13h45-17h (pause 15h15-15h30)](#prof-13h45-17h-pause-15h15-15h30)
      - [√âl√®ve](#√©l√®ve-2)
  - [Mercredi](#mercredi)
    - [Prof 9h30-10h30](#prof-9h30-10h30)
    - [√âl√®ve](#√©l√®ve-3)
  - [Jeudi](#jeudi)
    - [Prof 9h30-10h30](#prof-9h30-10h30-1)
    - [√âl√®ve](#√©l√®ve-4)
  - [Vendredi](#vendredi)
    - [Matin 9h30-10h30](#matin-9h30-10h30)
      - [Prof](#prof-1)
      - [√âl√®ve](#√©l√®ve-5)
    - [Apr√®m 13h45-17h (pause 15h15-15h30)](#apr√®m-13h45-17h-pause-15h15-15h30)
- [üìù Sujet](#-sujet)
  - [Exercices √† faire](#exercices-√†-faire)
  - [Rapport](#rapport)
  - [Soutenance](#soutenance)
  - [D√©tails techniques](#d√©tails-techniques)
- [üíª Exercices](#-exercices)
  - [‚≠ê Ne garder que le vert](#-ne-garder-que-le-vert)
  - [‚≠ê Noir \& Blanc](#-noir--blanc)
  - [‚≠ê Channels swap](#-channels-swap)
  - [‚≠ê N√©gatif](#-n√©gatif)
  - [‚≠ê‚≠ê Luminosit√©](#-luminosit√©)
  - [‚≠ê‚≠ê Miroir](#-miroir)
  - [‚≠ê‚≠ê Rotation de 90¬∞](#-rotation-de-90)
  - [‚≠ê‚≠ê Color glitch](#-color-glitch)
  - [‚≠ê‚≠ê‚≠ê Position glitch](#-position-glitch)
  - [‚≠ê‚≠ê‚≠ê Vortex](#-vortex)
  - [‚≠ê‚≠ê RGB split](#-rgb-split)
  - [‚≠ê Dessiner un d√©grad√©](#-dessiner-un-d√©grad√©)
  - [‚≠ê‚≠ê Dessiner un disque](#-dessiner-un-disque)
    - [‚≠ê Dessiner un cercle](#-dessiner-un-cercle)
    - [‚≠ê‚≠ê‚≠ê Dessiner une rosace](#-dessiner-une-rosace)
  - [‚≠ê‚≠ê‚≠ê Dessiner la fractale de Mandelbrot](#-dessiner-la-fractale-de-mandelbrot)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image](#-k-means--trouver-les-couleurs-les-plus-pr√©sentes-dans-une-image)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Convolutions](#-convolutions)
    - [‚≠ê‚≠ê Flou gaussien](#-flou-gaussien)
    - [‚≠ê‚≠ê Flou bokeh (appareil photo)](#-flou-bokeh-appareil-photo)
    - [‚≠ê‚≠ê Separable filter](#-separable-filter)
      - [‚≠ê‚≠ê Difference of gaussians](#-difference-of-gaussians)
  - [‚≠ê‚≠ê‚≠ê(‚≠ê) Histogram Equalization](#-histogram-equalization)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Affichage de l'histogramme](#-affichage-de-lhistogramme)
  - [‚≠ê‚≠ê Effet S√©pia](#-effet-s√©pia)
  - [Feel free to implement your own effects!](#feel-free-to-implement-your-own-effects)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Filtre de Kuwahara (effet peinture)](#-filtre-de-kuwahara-effet-peinture)
  - [‚≠ê‚≠ê‚≠ê Color palette dithering](#-color-palette-dithering)
  - [‚≠ê‚≠ê‚≠ê Tramage](#-tramage)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Pixel sorting](#-pixel-sorting)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square](#-diamond-square)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Flood Fill](#-flood-fill)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Canny Edge Detection](#-canny-edge-detection)
  - [‚≠ê‚≠ê Mosaic](#-mosaic)
    - [‚≠ê‚≠ê‚≠ê Mosaic flip](#-mosaic-flip)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ray Tracing](#-ray-tracing)


## üìÖ Planning

### Lundi

#### Prof 9h30-12h45 (pause 11h00-11h15)

- [ ] Pr√©sentation de moi
- [ ] Pr√©sentation du projet
  - [ ] C'est quoi le sujet? -> faire des effets sur les images, comme on peut en trouver dans photoshop etc, filtre insta etc
  - [ ] Par groupe de 2, et 1 groupe de 3 si impair
  - [ ] Evaluation: min 1 exo de niveau 3 ou +, et autant du reste que possible. Montrez moi juste que vous √™tes investies, 4h d'autonomie par jour c'est tr√®s bien. Posez un max de question, quand vous √™tes bloqu√©es et/ou par curiosit√©.
  - [ ] Je vous encourage √† dans un premier temps essayer de faire chaque exercice sans regarder les indices, ni chercher sur internet / ChatGPT. Essayez de r√©soudre le probl√®me par vous-m√™me, √ßa aide √† mieux le comprendre, puis appr√©cier et retenir la solution. + si vous r√©ussissez seul.e, giga satisfaction. Les exos sont "faciles", c'est fait pour. Bien s√ªr que ChatGPT peut les r√©soudre, mais vous n'apprendrez rien si vous n'essayez pas par vous m√™me. Et plut√¥t que ChatGPT, demandez moi en premier si possible, je pourrai mieux vous aiguiller / expliquez juste comme il faut pour que vous appreniez un max. Ou sinon demandez √† vos camarades en deuxi√®me solution (+ c'est un bon exercice d'expliquer donc vous rendez service √† la fois √† vous-m√™me et √† elleux)   
- [ ] Pr√©sentation de la lib
  - [ ] Parler de la repr√©sentation des couleurs en vec3 avec des valeurs de 0 √† 1
  - [ ] Mentionner que pour faire les choses bien il ne faudrait pas travailler en sRGB mais dans un espace perceptuellement correct (CIELab, Oklab)
  - [ ] Mentionner que la lib n'est pas un exemple de la meilleure API de l'univers, elle est minimaliste pour les forcer √† √©crire un max de code, se rendre compte des probl√®mes qui peuvent survenir, pas trop leur m√¢cher le travail. (Par exemple, on devrait permettre de g√©rer un wrap mode, et faire les conversions d'espace de couleur automatiquement, et pouvoir it√©rer sur les lignes ou sur les colonnes, et aussi le fait que le chemins soient relatifs au dossier contenant le CMakeLists.txt c'est atroce en production)

#### √âl√®ve

- [ ] Cr√©ation du groupe : bin√¥me obligatoirement (et 1 trin√¥me dans la classe si impair)
- [ ] Prise en main de la lib
- [ ] Quelques exercices de niveau 1 (‚≠ê) et/ou 2 (‚≠ê‚≠ê)

### Mardi

#### Matin 9h30-12h45 (pause 11h00-11h15)

##### Prof

- [ ] Pr√©sentation de git

##### √âl√®ve

- [ ] Cr√©ation du git
- [ ] Test et prise en main de git (l'un push quelque chose et l'autre le pull par exemple)
- [ ] Mettre sur le repository les exercices que vous avez fait hier

#### Apr√®m

##### Prof 13h45-17h (pause 15h15-15h30)

- [ ] Pr√©sentation des algos avanc√©s (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê)
- [ ] Conseil : faites un fichier √† part pour votre algo avanc√©, car il y aura probablement plusieurs fonctions interm√©diaires √† √©crire, et peut-√™tre des structs aussi.

##### √âl√®ve

- [ ] Choix de l'algo que vous allez impl√©menter (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê)
- [ ] Commencer √† vous renseigner sur votre algo avanc√©, √† l'impl√©menter

### Mercredi

#### Prof 9h30-10h30

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes, regarder l'algo avanc√© qu'iels ont choisi.


#### √âl√®ve

- [ ] Avancer sur l'algo avanc√©

### Jeudi

#### Prof 9h30-10h30

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes et d√©cider qui pr√©sente quel algo. Possibilit√© que plusieurs groupes se mettent ensemble pour pr√©senter leur algo si tout le monde a envie de passer.

#### √âl√®ve

- [ ] Finir votre algo avanc√©


### Vendredi

#### Matin 9h30-10h30

##### Prof

- [ ] Pr√©sentation de Markdown pour l'√©criture du rapport
  - [ ] Extension VSCode, et comment elle permet de g√©n√©rer une Table of Content
  - [ ] Syntaxe basique (titres, gras, italique), et si voulez vous pouvez aller voir comment [le document que vous √™tes en train de lire](TODO mettre le lien du sujet qui est sur le git) est √©crit, c'est du markdown !
  - [ ] Mettre des images (s'assurer du coup que leur dossier output soit √† la racine du repo, et soit commit)
  - [ ] Vous pouvez mettre du html si vous voulez faire des trucs + avanc√©s.

##### √âl√®ve

- [ ] √âcriture du rapport. (Vous avez jusqu'√† lundi matin pour les rendre).
- [ ] Pr√©paration de la pr√©sentation pour celleux concern√©.es

#### Apr√®m 13h45-17h (pause 15h15-15h30)

- [ ] Pr√©sentations


## üìù Sujet

### Exercices √† faire

Faites un maximum de chose, et au minimum un exercice de niveau 3 ou plus (‚≠ê‚≠ê‚≠ê). Vous √™tes aussi les bienvenu.es pour inventer vos propres effets !

### Rapport

A faire en Markdown obligatoirement (si vous ne connaissez pas c'est l'occasion de d√©couvrir, c'est super utile).

A mettre directement en tant que readme √† la racine du repo.

Faite une section par exercice que vous avez fait. Montrez une image avant et apr√®s application de l'effet (comme c'est fait dans l'√©nonc√© des exercices). Si vous jugez cela utile, vous pouvez mettre un petit texte expliquant des sp√©cificit√©s de l'algo que vous avez impl√©ment√©. (C'est surtout int√©ressant si vous avez fait des algos qui ne sont pas list√©s dans le sujet, et pour votre algo 3+).

### Soutenance

Pr√©sentez un des algos avanc√©s que vous avez fait, en 5 minutes. C'est de la vulgarisation, il faut que tous vos camarades puissent comprendre, au moins dans les grandes lignes.

> Est-ce que c'est utile ? Ca prend pas mal de temps. Mais de l'autre c√¥t√© c'est un bon exercice qui force √† avoir bien compris l'algo, et √ßa permet aux autres de voir les algos qu'iels n'ont pas impl√©ment√©. Ou sinon, je demande juste aux groupes les plus chauds de faire une pr√©sentation, comme √ßa c'est pas trop long, et on voit juste une fois chaque algo. Et on peut prendre + de temps pour chaque pr√©sentation (m√™me pas besoin de limiter le temps, iels font comme bon leur semble).

### D√©tails techniques

Nous utiliserons la librairie *sil* pour lire, √©diter et re-sauvegarder les images. Elle est tr√®s simple √† utiliser et n'expose que le minimum n√©cessaire. Vous pouvez trouver sa documentation [sur GitHub](https://github.com/JulesFouchy/Simple-Image-Lib/tree/main#usage).

## üíª Exercices

- Leur dire de travailler sur une image pas trop grande, pour que le rendu soit quasi-instantan√©. (Par exemple l'image par d√©faut fournie dans le projet est tr√®s bien. Mais il faut leur fournir aussi une photo, certains effets ne marchent pas bien sur une image en flat design).
- Leur dire d'afficher l'image output √† c√¥t√© dans VSCode pour facilement voir le r√©sultat
![Alt text](image.png)

### ‚≠ê Ne garder que le vert

![](output/keep_green_only.png)

<details><summary>Indice</summary>
Mettre le rouge et le bleu √† 0.
</details>

### ‚≠ê Noir & Blanc

![](output/black_and_white.png)

N'h√©sitez pas √† **aller chercher la formule sur internet** si besoin !

### ‚≠ê Channels swap

![](output/channels_swap.png)

Par exemple, √©changez le canal rouge et le canal bleu.

### ‚≠ê N√©gatif

![](output/negative.png)

### ‚≠ê‚≠ê Luminosit√©

| ![](images/photo.jpg)  | ![](output/luminosity+.jpg)  |![](output/luminosity-.jpg)  |
|---|----|----|
| Image originale | Apr√®s √©claircissement | Apr√®s assombrissement |

<details><summary>Indice</summary>
On voudrait des courbes comme celles-ci, qui diminuent tous les nombres entre 0 et 1 (c-√†-d assombrissent), ou les augmentent (c-√†-d √©claircissent), tout en gardant 0 √† 0 et 1 √† 1 (afin de garder la plage dynamique de l'image, pour conserver des noirs purs et des blancs purs).
<img src ="image-1.png"/>


<details><summary>Indice 2</summary>
Les fonctions puissance font exactement ce qu'on veut!<br/>
La preuve: <a src="https://www.desmos.com/calculator/c3ztk51mng">https://www.desmos.com/calculator/c3ztk51mng</a>
</details>
</details>

### ‚≠ê‚≠ê Miroir

![](output/mirror.png)

Sym√©trie par rapport √† l'axe Y (vertical).

### ‚≠ê‚≠ê Rotation de 90¬∞

![](output/rotate_90_degrees.png)

La formule g√©n√©rique pour un angle quelconque est un peu plus compliqu√©e, mais pour 90¬∞ il y a une formule vraiment simple, essayez de la trouver !

### ‚≠ê‚≠ê Color glitch

![](output/color_glitch.png)

Remplacer quelques pixels au hasard par une couleur al√©atoire.

Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê Position glitch

![](output/position_glitch.png)

Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

<details><summary>Indice</summary>
Prendre un rectangle de pixels et l'intervertir avec un autre rectangle de pixels, ailleurs dans l'image. Faire √ßa plusieurs fois.
</details>

### ‚≠ê‚≠ê‚≠ê Vortex

![](output/vortex.png)

<details><summary>Indice</summary>
Chaque pixel subit une rotation, de plus en plus importante au fur et √† mesure qu'on s'√©loigne du centre.
</details>

### ‚≠ê‚≠ê RGB split

![](output/rgb_split.png)

‚ö†Ô∏è Cr√©ez une nouvelle image et travaillez sur celle-ci. Il ne faut pas modifier l'image originale pendant que vous bouclez pour appliquer l'effet, sinon certains pixels n'utiliseront pas la bonne couleur de l'image originale, mais plut√¥t la couleur d√©j√† modifi√©e par un pixel pr√©c√©dent, ce qui pourrait vous donner ce genre de rendu moins int√©ressant :

![](output/rgb_split_incorrect.png)

### ‚≠ê Dessiner un d√©grad√©

![](output/gradient.png)

Vous pouvez cr√©er une image noire avec
```cpp
sil::Image image{300/*width*/, 200/*height*/};
```
puis it√©rer sur les pixels pour les colorer.

### ‚≠ê‚≠ê Dessiner un disque

![](output/disk.png)

Vous pouvez cr√©er une image noire avec
```cpp
sil::Image image{500/*width*/, 500/*height*/};
```

<details><summary>Indice</summary>
Ensuite, √† vous de parcourir les pixels et de les colorier ou non en fonction de si ils sont √† l'int√©rieur du disque. La fonction prendra en param√®tre le centre et le rayon du disque.
</details>

#### ‚≠ê Dessiner un cercle

![](output/circle.png)

En reprenant et modifiant l√©g√®rement votre code pour le disque, √©crivez le code qui donne un cercle. (Son contour aura une √©paisseur donn√©e `thickness`).

#### ‚≠ê‚≠ê‚≠ê Dessiner une rosace

![](output/rosace.png)

Maintenant que vous savez dessiner un cercle, dessinez-en plusieurs sur la m√™me image, √† des positions bien choisies, de sorte √† dessiner une rosace.
(PS: il va surement falloir faire de la trigo!)

### ‚≠ê‚≠ê‚≠ê Dessiner la fractale de Mandelbrot

![](output/mandelbrot.png)

<details><summary>Indice</summary>
D√©finir un nombre max d'it√©rations, it√©rer `z <- z * z + c` jusqu'√† ce qu'on d√©passe ce nombre d'it√©rations ou que la norme de z soit > 2, puis assigner une couleur en fonction du nombre d'it√©rations qu'on a fait avant de sortir de la boucle.
</details>

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image

| ![](images/photo.jpg)  | ![](output/k_means_2_colors.jpg) | ![](output/k_means_3_colors.jpg)  | ![](output/k_means_16_colors.jpg)  |
|---|----|----|----|
| Originale | 2 couleurs | 3 couleurs | 16 couleurs |

Trouvez les k couleurs les plus repr√©sentatives de l'image, puis assignez √† chaque pixel la couleur dont il est le plus proche parmi les k.

Voici une bonne vid√©o expliquant l'algorithme :

[![k-means video](https://img.youtube.com/vi/yR7k19YBqiw/0.jpg)](https://www.youtube.com/watch?v=yR7k19YBqiw)

Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê‚≠ê Convolutions

![](output/box_blur.png)
Box blur

#### ‚≠ê‚≠ê Flou gaussien

#### ‚≠ê‚≠ê Flou bokeh (appareil photo)

![](output/bokeh_blur.png)

#### ‚≠ê‚≠ê Separable filter

https://youtu.be/SiJpkucGa1o

##### ‚≠ê‚≠ê Difference of gaussians

https://youtu.be/5EuYKEvugLU

Ne faire que le d√©but √ßa suffit, jusqu'√† 4m09.

### ‚≠ê‚≠ê‚≠ê(‚≠ê) Histogram Equalization

| ![](images/photo_faible_contraste.jpg)  | ![](output/normalize_histogram.jpg)  |
|---|----|
| Avant | Apr√®s |

Am√©lioration du contraste, en calculant la luminosit√© min et max, et en appliquant une transformation qui va mapper le plus sombre √† 0 et le plus clair √† 1.
(PS: testez avec l'image "images/photo_faible_contraste.jpg", vous verrez bien l'int√©r√™t de l'effet.)

### ‚≠ê‚≠ê‚≠ê‚≠ê Affichage de l'histogramme

S'inspirer de Lightroom. Potentiellement split les histogrammes R, G et B

### ‚≠ê‚≠ê Effet S√©pia

### Feel free to implement your own effects!

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Filtre de Kuwahara (effet peinture)

![](output/kuwahara.jpg)

https://youtu.be/LDhN-JK3U9g

(Juste la version simple, qui est expliqu√©e entre 3:11 et 3:30, suffit. Si vous voulez aller plus loin, vous √™tes les bienvenu.es bien s√ªr üòâ)

### ‚≠ê‚≠ê‚≠ê Color palette dithering

https://youtu.be/8wOUe32Pt-E

### ‚≠ê‚≠ê‚≠ê Tramage

![](output/ordered_dithering.png)

Vous pouvez lire [ce super article](https://surma.dev/things/ditherpunk/) sur le tramage (a.k.a. *dithering* en anglais).

Sur l'image ci-dessus j'ai utilis√© de l'*ordered dithering* avec une matrice de Bayer 4x4 (a.k.a. de niveau 1). Tout est expliqu√© dans l'article ci-dessus ! (Plus pr√©cis√©ment, j'ai repris la matrice et le code depuis [cet autre article](https://medium.com/the-bkpt/dithered-shading-tutorial-29f57d06ac39).)

### ‚≠ê‚≠ê‚≠ê‚≠ê Pixel sorting

![](output/pixel_sorting.png)

Voici une bonne vid√©o expliquant l'algorithme (vous pouvez ignorer le d√©but sp√©cifique √† Processing o√π on voit comment afficher l'image) :

[![pixel sorting video](https://img.youtube.com/vi/JUDYkxU6J0o/0.jpg)](https://www.youtube.com/watch?v=JUDYkxU6J0o)

Ensuite, au lieu de trier tous les pixels de l'image, triez par colonne (ou par ligne), pour un effet plus joli.

Pour trier un tableau, vous pouvez utiliser [`std::sort`](https://www.geeksforgeeks.org/sort-c-stl/).

Plut√¥t que d'utiliser `get_pixel()` vous avez probablement int√©r√™t √† utiliser √† utiliser `pixels()` pour r√©cup√©rer le tableau contenant tous les pixels de l'image.

Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square

https://youtu.be/4GuAV1PnurU

### ‚≠ê‚≠ê‚≠ê‚≠ê Flood Fill

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Canny Edge Detection

### ‚≠ê‚≠ê Mosaic

![](output/mosaic.png)

<details><summary>Indice</summary>
You can use a modulo (`%`) somewhere.
</details>

#### ‚≠ê‚≠ê‚≠ê Mosaic flip

Flip every other image:

![](output/mosaic_flip.png)

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Ray Tracing

A minima une sph√®re et un shading basique.

Pour calculer le shading pour une sph√®re :
```cpp
glm::vec3 const light_direction = glm::normalize(glm::vec3{1.f, 3.f, 10.f});
glm::vec3 const light_color = glm::vec3(1.f, 1.f, 0.f);   // Yellow for the sun
glm::vec3 const ambient_color = glm::vec3(0.f, 0.f, 1.f); // Slight blue for the sky

glm::vec3 const normal = glm::normalize(intersection_point_with_the_sphere - center_of_the_sphere); // Attention cette formule ne marche que parce que c'est une sph√®re!
float const light_intensity = std::clamp(glm::dot(light_direction, normal), 0.f, 1.f);
glm::vec3 const final_color = ambient_color + light_intensity * light_color;
```

Voici une bonne vid√©o expliquant les maths dont vous aurez besoin :

[![raytracing video](https://img.youtube.com/vi/4NshnkzOdI0/0.jpg)](https://www.youtube.com/watch?v=4NshnkzOdI0)