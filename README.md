# üê£ S1 | Prog: Workshop (Solution)

- [üìÖ Planning](#-planning)
  - [Lundi](#lundi)
    - [Prof 9h30-12h45 (pause 11h00-11h15)](#prof-9h30-12h45-pause-11h00-11h15)
    - [√âl√®ve](#√©l√®ve)
  - [Mardi](#mardi)
    - [Matin 9h30-12h45 (pause 11h00-11h15)](#matin-9h30-12h45-pause-11h00-11h15)
      - [Prof](#prof)
      - [√âl√®ve](#√©l√®ve-1)
    - [Apr√®m](#apr√®m)
      - [Prof 13h45-17h (pause 15h15-15h30)](#prof-13h45-17h-pause-15h15-15h30)
      - [√âl√®ve](#√©l√®ve-2)
  - [Mercredi](#mercredi)
    - [Prof 9h30-10h30](#prof-9h30-10h30)
    - [√âl√®ve](#√©l√®ve-3)
  - [Jeudi](#jeudi)
    - [Prof 9h30-10h30](#prof-9h30-10h30-1)
    - [√âl√®ve](#√©l√®ve-4)
  - [Vendredi](#vendredi)
    - [Matin 9h30-10h30](#matin-9h30-10h30)
      - [Prof](#prof-1)
      - [√âl√®ve](#√©l√®ve-5)
    - [Apr√®m 13h45-17h (pause 15h15-15h30)](#apr√®m-13h45-17h-pause-15h15-15h30)
- [üìù Sujet](#-sujet)
  - [Exercices √† faire](#exercices-√†-faire)
  - [Rapport](#rapport)
  - [Soutenance](#soutenance)
- [üíª Exercices](#-exercices)
  - [Conseils](#conseils)
  - [‚≠ê Ne garder que le vert](#-ne-garder-que-le-vert)
  - [‚≠ê √âchanger les canaux](#-√©changer-les-canaux)
  - [‚≠ê Noir \& Blanc](#-noir--blanc)
  - [‚≠ê N√©gatif](#-n√©gatif)
  - [‚≠ê D√©grad√©](#-d√©grad√©)
  - [‚≠ê‚≠ê Miroir](#-miroir)
  - [‚≠ê‚≠ê Image bruit√©e](#-image-bruit√©e)
  - [‚≠ê‚≠ê Rotation de 90¬∞](#-rotation-de-90)
  - [‚≠ê‚≠ê RGB split](#-rgb-split)
  - [‚≠ê‚≠ê Luminosit√©](#-luminosit√©)
  - [‚≠ê‚≠ê Disque](#-disque)
    - [‚≠ê Cercle](#-cercle)
    - [‚≠ê‚≠ê‚≠ê Rosace](#-rosace)
  - [‚≠ê‚≠ê Mosa√Øque](#-mosa√Øque)
    - [‚≠ê‚≠ê‚≠ê Mosa√Øque miroir](#-mosa√Øque-miroir)
  - [‚≠ê‚≠ê‚≠ê Glitch](#-glitch)
  - [‚≠ê‚≠ê‚≠ê Fractale de Mandelbrot](#-fractale-de-mandelbrot)
  - [‚≠ê‚≠ê‚≠ê Vortex](#-vortex)
  - [‚≠ê‚≠ê‚≠ê(‚≠ê) Tramage](#-tramage)
  - [‚≠ê‚≠ê‚≠ê(‚≠ê) Normalisation de l'histogramme](#-normalisation-de-lhistogramme)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Convolutions](#-convolutions)
    - [‚≠ê Nettet√©, Contours, etc.](#-nettet√©-contours-etc)
    - [‚≠ê‚≠ê Filtres s√©parables](#-filtres-s√©parables)
    - [‚≠ê‚≠ê Diff√©rence de gaussiennes](#-diff√©rence-de-gaussiennes)
  - [‚≠ê‚≠ê‚≠ê‚≠ê Tri de pixels](#-tri-de-pixels)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Filtre de Kuwahara (effet peinture √† l'huile)](#-filtre-de-kuwahara-effet-peinture-√†-lhuile)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image](#-k-means--trouver-les-couleurs-les-plus-pr√©sentes-dans-une-image)
  - [‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square](#-diamond-square)
    - [‚≠ê‚≠ê Colorer la height map](#-colorer-la-height-map)
  - [Vous pouvez impl√©menter vos propres effets !](#vous-pouvez-impl√©menter-vos-propres-effets-)

## üìÖ Planning

### Lundi

#### Prof 9h30-12h45 (pause 11h00-11h15)

- [ ] Pr√©sentation de moi
- [ ] Pr√©sentation du projet
  - [ ] C'est quoi le sujet? -> faire des effets sur les images, comme on peut en trouver dans photoshop, filtre insta etc
  - [ ] Par groupe de 2, et 1 groupe de 3 si impair. Mais je veux que vous fassiez chacun des exercices de votre c√¥t√© autant que possible, et que vous vous entraidiez au besoin. √Ä partir des exercice de niveau 3 ou + vous pouvez bosser √† deux dessus d√®s le d√©but.
  - [ ] √âvaluation: min 1 exo de niveau 3 ou +, et autant du reste que possible. Montrez moi juste que vous √™tes investies, 4h d'autonomie par jour c'est tr√®s bien. Posez un max de question, quand vous √™tes bloqu√©es et/ou par curiosit√©.
  - [ ] Je vous encourage √† dans un premier temps essayer de faire chaque exercice sans regarder les indices, ni chercher sur internet / ChatGPT. Essayez de r√©soudre le probl√®me par vous-m√™me, √ßa aide √† mieux le comprendre, puis appr√©cier et retenir la solution. + si vous r√©ussissez seul.e, giga satisfaction. Les exos sont "faciles", c'est fait pour. Bien s√ªr que ChatGPT peut les r√©soudre, mais vous n'apprendrez rien si vous n'essayez pas par vous m√™me. Et plut√¥t que ChatGPT, demandez moi en premier si possible, je pourrai mieux vous aiguiller / expliquer juste comme il faut pour que vous appreniez un max. Ou sinon demandez √† vos camarades en deuxi√®me solution (+ c'est un bon exercice d'expliquer donc vous rendez service √† la fois √† vous-m√™me et √† elleux)   
- [ ] Pr√©sentation de la lib
  - [ ] Parler de la repr√©sentation des couleurs en vec3 avec des valeurs de 0 √† 1
  - [ ] Mentionner que pour faire les choses bien il ne faudrait pas travailler en sRGB mais dans un espace perceptuellement correct (CIELab, Oklab)
  - [ ] Mentionner que la lib n'est pas un exemple de la meilleure API de l'univers, elle est minimaliste pour les forcer √† √©crire un max de code, se rendre compte des probl√®mes qui peuvent survenir, pas trop leur m√¢cher le travail. (Par exemple, on devrait permettre de g√©rer un wrap mode, et faire les conversions d'espace de couleur automatiquement, et pouvoir it√©rer sur les lignes ou sur les colonnes, et aussi le fait que le chemins soient relatifs au dossier contenant le CMakeLists.txt c'est atroce en production)

#### √âl√®ve

- [ ] Cr√©ation du groupe : bin√¥me obligatoirement (et 1 trin√¥me dans la classe si impair) mais je veux que vous fassiez chacun des exercices de votre c√¥t√© autant que possible, et que vous vous entraidiez au besoin. √Ä partir des exercice de niveau 3 ou + vous pouvez bosser √† deux dessus d√®s le d√©but.
- [ ] Prise en main de la lib
- [ ] Quelques exercices de niveau 1 (‚≠ê) et/ou 2 (‚≠ê‚≠ê)

### Mardi

#### Matin 9h30-12h45 (pause 11h00-11h15)

##### Prof

- [ ] Pr√©sentation de git

##### √âl√®ve

- [ ] Cr√©ation du git
- [ ] Test et prise en main de git (l'un push quelque chose et l'autre le pull par exemple)
- [ ] Mettre sur le repository les exercices que vous avez fait hier

#### Apr√®m

##### Prof 13h45-17h (pause 15h15-15h30)

- [ ] Lancement des algos avanc√©s (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê), accompagnement, conseils

##### √âl√®ve

- [ ] Choix de l'algo que vous allez impl√©menter (niveau 3 ou plus ‚≠ê‚≠ê‚≠ê)
- [ ] Commencer √† vous renseigner sur votre algo avanc√©, √† l'impl√©menter

### Mercredi

#### Prof 9h30-10h30

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes, regarder l'algo avanc√© qu'iels ont choisi.


#### √âl√®ve

- [ ] Avancer sur l'algo avanc√©

### Jeudi

#### Prof 9h30-10h30

- [ ] Si besoin, point de rappel sur une notion mal acquise.
- [ ] Passer voir les groupes et d√©cider qui pr√©sente quel algo. Possibilit√© que plusieurs groupes se mettent ensemble pour pr√©senter leur algo si tout le monde a envie de passer.

#### √âl√®ve

- [ ] Finir votre algo avanc√©

### Vendredi

#### Matin 9h30-10h30

##### Prof

- [ ] Pr√©sentation de Markdown pour l'√©criture du rapport
  - [ ] Extension VSCode, et comment elle permet de g√©n√©rer une Table of Content
  - [ ] Syntaxe basique (titres, gras, italique, blocs de code, bloc quote, liste), et si voulez vous pouvez aller voir comment [le document que vous √™tes en train de lire](TODO mettre le lien du sujet qui est sur le git) est √©crit, c'est du markdown !
  - [ ] [Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet)
  - [ ] Mettre des images (s'assurer du coup que leur dossier output soit √† la racine du repo, et soit commit)
  - [ ] Vous pouvez mettre du html si vous voulez faire des trucs + avanc√©s.

##### √âl√®ve

- [ ] √âcriture du rapport. (Vous avez jusqu'√† lundi matin pour les rendre).
- [ ] Pr√©paration de la pr√©sentation pour celleux concern√©.es

#### Apr√®m 13h45-17h (pause 15h15-15h30)

- [ ] Pr√©sentations


## üìù Sujet

### Exercices √† faire

Faites un maximum de chose, et au minimum un exercice de niveau 3 ou plus (‚≠ê‚≠ê‚≠ê). Vous √™tes aussi les bienvenu.es pour inventer vos propres effets !

### Rapport

√Ä faire en Markdown obligatoirement (si vous ne connaissez pas c'est l'occasion de d√©couvrir, c'est super utile).

√Ä mettre directement en tant que ReadMe √† la racine du repo.

Faites une section par exercice que vous avez fait. Montrez une image avant et apr√®s application de l'effet (comme c'est fait dans l'√©nonc√© des exercices). Si vous jugez cela utile, vous pouvez mettre un petit texte expliquant des sp√©cificit√©s de l'algo que vous avez impl√©ment√©. (C'est surtout int√©ressant si vous avez fait des algos qui ne sont pas list√©s dans le sujet, et pour vos algo 3+).

Mettez un lien vers votre git au d√©but du rapport.

### Soutenance

Pr√©sentez un des algos avanc√©s que vous avez fait, en 5-10 minutes. C'est de la vulgarisation, il faut que tous vos camarades puissent comprendre, au moins dans les grandes lignes.

## üíª Exercices

### Conseils

- Nous utiliserons la librairie *sil* pour lire, √©diter et sauvegarder les images. Elle est tr√®s simple √† utiliser et n'expose que le minimum n√©cessaire. Vous pouvez trouver sa documentation [sur GitHub](https://github.com/JulesFouchy/Simple-Image-Lib/tree/main#usage).
- Utilisez des images relativement petites (500x500 max), pour que le rendu soit quasi-instantan√©. Au moins pendant que vous faites vos tests.
- Vous pouvez afficher l'image de sortir √† c√¥t√© dans VSCode pour facilement voir le r√©sultat:
![Alt text](image.png)

### ‚≠ê Ne garder que le vert

![](output/keep_green_only.png)

<details><summary>Indice</summary>

Mettre le rouge et le bleu √† 0.
</details>

### ‚≠ê √âchanger les canaux

![](output/channels_swap.png)

Par exemple, √©changez le canal rouge et le canal bleu.

<details><summary>Indice</summary>

Il existe `std::swap(a, b)` pour √©changer deux valeurs.
</details>

### ‚≠ê Noir & Blanc

![](output/black_and_white.png)

<details><summary>Indice</summary>

N'h√©sitez pas √† **aller chercher la formule sur internet** si besoin !
</details>

### ‚≠ê N√©gatif

![](output/negative.png)

<details><summary>Indice</summary>

Il faut trouver une formule simple, qui transforme le noir en blanc et le blanc en noir (i.e. qui transforme 0 en 1 et 1 en 0).
</details>

### ‚≠ê D√©grad√©

![](output/gradient.png)

> Vous pouvez cr√©er une image noire avec
> ```cpp
> sil::Image image{300/*width*/, 200/*height*/};
> ```
> puis it√©rer sur les pixels pour les colorer.

<details><summary>Indice</summary>

La couleur de chaque pixel doit d√©pendre de son x uniquement.
</details>

<details><summary>Indice 2</summary>

Quelle formule permettrait d'avoir 0 (noir) quand x vaut 0 (gauche), et 1 (blanc) quand x vaut `image.width() - 1` (droite).
</details>

### ‚≠ê‚≠ê Miroir

![](output/mirror.png)

<details><summary>Indice</summary>

Il va falloir parcourir la moiti√© gauche de l'image, et l'√©changer avec la partie droite de l'image.
</details>

### ‚≠ê‚≠ê Image bruit√©e

![](output/noisy_image.png)

<details><summary>Indice</summary>

Remplacer quelques pixels au hasard par une couleur al√©atoire.
</details>

*Info:*
> Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê Rotation de 90¬∞

![](output/rotate_90_degrees.png)

La formule g√©n√©rique pour un angle quelconque est un peu plus compliqu√©e, mais pour 90¬∞ il y a une formule vraiment simple, essayez de la trouver !

### ‚≠ê‚≠ê RGB split

![](output/rgb_split.png)

<details><summary>Indice</summary>

Chaque pixel va prendre comme couleur le rouge d'un pixel un peu √† sa droite, son propre vert, et le bleu d'un pixel un peu √† sa gauche.
</details>

<details><summary>‚ö†Ô∏è Pi√®ge √† ne pas tomber dedans</summary>

Cr√©ez une nouvelle image et travaillez sur celle-ci. Il ne faut pas modifier l'image originale pendant que vous bouclez pour appliquer l'effet, sinon certains pixels n'utiliseront pas la bonne couleur de l'image originale, mais plut√¥t la couleur d√©j√† modifi√©e par un pixel pr√©c√©dent, ce qui pourrait vous donner ce genre de rendu moins int√©ressant :

![](output/rgb_split_incorrect.png)
</details>

### ‚≠ê‚≠ê Luminosit√©

| ![](images/photo.jpg)  | ![](output/luminosity+.jpg)  |![](output/luminosity-.jpg)  |
|---|----|----|
| Image originale | Apr√®s √©claircissement | Apr√®s assombrissement |

<details><summary>Indice</summary>

On voudrait des courbes comme celles-ci, qui diminuent tous les nombres entre 0 et 1 (courbe bleue) (c-√†-d assombrisse), ou les augmentent (courbe verte) (c-√†-d √©claircisse), tout en gardant 0 √† 0 et 1 √† 1 (afin de garder la plage dynamique de l'image, pour conserver des noirs purs et des blancs purs).
![](image-1.png)
</details>
<details><summary>Indice 2</summary>

Les fonctions puissance font exactement ce qu'on veut!
La preuve: https://www.desmos.com/calculator/c3ztk51mng
</details>

### ‚≠ê‚≠ê Disque

![](output/disk.png)

> Vous pouvez cr√©er une image noire avec
> ```cpp
> sil::Image image{500/*width*/, 500/*height*/};
> ```
> puis it√©rer sur les pixels pour les colorer.

<details><summary>Indice</summary>

Quelle est l'√©quation d'un disque ? Comment peut on s'en servir pour savoir si un pixel est √† l'int√©rieur ou √† l'ext√©rieur du disque ?
</details>

#### ‚≠ê Cercle

![](output/circle.png)

En reprenant et modifiant l√©g√®rement votre code pour le disque, √©crivez le code qui donne un cercle. (Son contour aura une √©paisseur donn√©e `thickness`).

#### ‚≠ê‚≠ê‚≠ê Rosace

![](output/rosace.png)

Maintenant que vous savez dessiner un cercle, dessinez-en plusieurs sur la m√™me image, √† des positions bien choisies, de sorte √† dessiner une rosace.
(PS: il va s√ªrement falloir faire de la trigo!)

<details><summary>Indice</summary>

Comment passer de coordonn√©es polaires (angle et rayon) √† des coordonn√©es cart√©siennes (x et y) ?
</details>

### ‚≠ê‚≠ê Mosa√Øque

![](output/mosaic.png)

<details><summary>Indice</summary>

Une mani√®re concise de faire √ßa est d'utiliser un modulo (`%`) quelque part.
</details>

#### ‚≠ê‚≠ê‚≠ê Mosa√Øque miroir

Inversez une image sur deux :

![](output/mosaic_mirror.png)

### ‚≠ê‚≠ê‚≠ê Glitch

![](output/glitch.png)

<details><summary>Indice</summary>
Prendre un rectangle de pixels et l'intervertir avec un autre rectangle de pixels, ailleurs dans l'image. Faire √ßa plusieurs fois.
</details>

*Info:*
> Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê Fractale de Mandelbrot

![](output/mandelbrot.png)

La fractale de Mandelbrot s'obtient ainsi: pour chaque nombre complexe `c`, on initialise un autre nombre complexe `z` √† 0, puis on it√®re `z = z * z + c` un certain nombre de fois. Si le nombre `z` commence √† devenir de plus en plus grand, alors `c` ne fait pas partie de la fractale et on colorie le pixel correspondant en noir. √Ä l'inverse, si `z` reste de taille mod√©r√©e peu importe le nombre d'it√©rations qu'on fait, alors le pixel fait partie de la fractale et on le colorie en blanc.

Plus pr√©cis√©ment, on peut prouver que d√®s que `std::abs(z) > 2` alors le nombre `z` va forc√©ment finir par grandir de plus en plus. On peut donc s'arr√™ter d'it√©rer d√®s que `std::abs(z) > 2`. Et pour obtenir une fractale plus jolie, plut√¥t que d'assigner du noir pur on peut assigner un gris plus ou moins sombre en fonction du nombre d'it√©rations qu'il a fallu faire avant que `std::abs(z) > 2`.

Conseil: si vous mappez directement le pixel (x, y) au nombre complexe x + i * y, vous allez visualiser les nombres complexes entre 0 et 500, et votre fractale va √™tre beaucoup trop petite. Les nombres int√©ressants sont plut√¥t entre -2 et 2. Il va donc falloir appliquer une petite transformation √† votre x et y pour les faire rentrer dans cet intervalle.

Conseil: vous pouvez inclure le header `<complex>` pour utiliser des nombres complexes. Un nombre complexe se d√©finit comme √ßa:
```cpp
#include <complex>
int main()
{
    std::complex<float> z{3.f, 2.f}; // D√©finis le nombre z = 3 + 2*i
}
```
et s'utilise comme un nombre normal: vous pouvez faire des additions, multiplications etc.

> Vous pouvez cr√©er une image noire avec
> ```cpp
> sil::Image image{500/*width*/, 500/*height*/};
> ```
> puis it√©rer sur les pixels pour les colorer.

### ‚≠ê‚≠ê‚≠ê Vortex

![](output/vortex.png)

*Info:*
> Pour appliquer une rotation √† un `glm::vec2` vous pouvez utiliser
> ```cpp
> glm::vec2 rotated(glm::vec2 v, float angle)
> {
>     return glm::vec2{glm::rotate(glm::mat3{1.f}, angle) * glm::vec3{v, 0.f}};
> } 
> ```

<details><summary>Indice</summary>
Chaque pixel subit une rotation, de plus en plus importante au fur et √† mesure qu'on s'√©loigne du centre.
</details>

### ‚≠ê‚≠ê‚≠ê(‚≠ê) Tramage

![](output/ordered_dithering.png)

Vous pouvez lire [ce super article](https://surma.dev/things/ditherpunk/) sur le tramage (a.k.a. *dithering* en anglais).

Sur l'image ci-dessus j'ai utilis√© de l'*ordered dithering* avec une matrice de Bayer 4x4 (a.k.a. de niveau 1). Tout est expliqu√© dans l'article ci-dessus ! (Plus pr√©cis√©ment, j'ai repris la matrice et le code depuis [cet autre article](https://medium.com/the-bkpt/dithered-shading-tutorial-29f57d06ac39).)

### ‚≠ê‚≠ê‚≠ê(‚≠ê) Normalisation de l'histogramme

| ![](images/photo_faible_contraste.jpg)  | ![](output/normalize_histogram.jpg)  |
|---|----|
| Avant | Apr√®s |

L'algorithme consiste √† trouver le pixel le moins lumineux et le pixel le plus lumineux de l'image, puis √† appliquer une transformation √† chaque pixel de sorte √† ce que le pixel le plus sombre devienne un noir pur (0) et le plus lumineux devienne un blanc pur (1).
(PS: testez avec l'image `"images/photo_faible_contraste.jpg"`, vous verrez bien l'int√©r√™t de l'effet.)

### ‚≠ê‚≠ê‚≠ê‚≠ê Convolutions

![](output/box_blur.png)
*Box blur*

Les convolutions permettent d'impl√©menter plein d'effets (flou, d√©tection de contour, augmentation de la nettet√©, etc.). L'effet va varier en fonction du *kernel* que vous utilisez lors de votre convolution. Tout est expliqu√© dans cette excellente vid√©o, entre 1m10 et 4m18:

[![convolution video](https://img.youtube.com/vi/8rrHTtUzyZA/0.jpg)](https://www.youtube.com/watch?v=8rrHTtUzyZA)

Conseil: une fois que vous savez que votre algo marche, si vous voulez tester avec des kernels plus gros, √ßa peut √™tre lent, donc vous avez int√©r√™t √† build en release et lancer sans debugger attach√© (demandez-moi si vous ne savez pas comment faire).

#### ‚≠ê Nettet√©, Contours, etc.

| ![](output/emboss.png)  | ![](output/outline.png)  |![](output/sharpen.png)  |
|---|----|----|
| Emboss | Outline | Sharpen |

Une fois que vous avez impl√©ment√© l'algo g√©n√©rique de convolution qui prend n'importe quel kernel, vous pourrez trouver sur [ce site](https://setosa.io/ev/image-kernels/) une liste de kernels pour faire diff√©rents effets.

#### ‚≠ê‚≠ê Filtres s√©parables

| Box blur na√Øf, 100x100  | Box blur s√©par√©, 100x100 |
|---|----|
| ![](output/big_box_blur.png) | ![](output/big_box_blur_separable_filter.png) |
| 7.44 secondes | 0.18 secondes |

Quand vous voulez faire un gros flou il faut augmenter la taille du kernel, ce qui peut consid√©rablement ralentir l'algorithme. Heureusement, certains kernels ont une propri√©t√© qui nous permet de calculer leur convolution **BEAUCOUP** plus rapidement. Le *box blur* et le *gaussian blur* sont de tels kernels. Voici une vid√©o expliquant tout √ßa :

[![separable filters video](https://img.youtube.com/vi/SiJpkucGa1o/0.jpg)](https://www.youtube.com/watch?v=SiJpkucGa1o)

#### ‚≠ê‚≠ê Diff√©rence de gaussiennes

![](output/difference_of_gaussians.png)

Voici une vid√©o expliquant l'algorithme:

- **NB 1:** Il parle de flou gaussien, mais vous pouvez tout aussi bien r√©utiliser votre box blur, pas la peine d'impl√©menter un flou gaussien.
- **NB 2:** Ne faire que l'algo de base, pr√©sent√© jusqu'√† 4m09. Apr√®s √ßa √ßa devient tr√®s compliqu√© (mais tr√®s styl√© n√©anmoins).

[![difference of gaussians video](https://img.youtube.com/vi/5EuYKEvugLU/0.jpg)](https://www.youtube.com/watch?v=5EuYKEvugLU)

### ‚≠ê‚≠ê‚≠ê‚≠ê Tri de pixels

![](output/pixel_sorting.png)

Voici une bonne vid√©o expliquant l'algorithme (vous pouvez ignorer le d√©but sp√©cifique √† Processing o√π on voit comment afficher l'image) :

[![pixel sorting video](https://img.youtube.com/vi/JUDYkxU6J0o/0.jpg)](https://www.youtube.com/watch?v=JUDYkxU6J0o)

Utilisez `image.pixels()` pour r√©cup√©rer le tableau contenant tous les pixels de l'image et le trier.

Ensuite, au lieu de trier tous les pixels de l'image, triez par colonne (ou par ligne) pour un effet plus joli. (Il faudra trier des sous-parties du tableau `image.pixels()`.) Ou encore, triez des sous-parties prises al√©atoirement dans l'image.

*Info:*
> Pour trier un tableau, vous pouvez utiliser `std::sort`. La fonction s'utilise ainsi:
> ```cpp
> std::vector<int> v{8, 5, 3, 1};
> std::sort(v.begin(), v.end()); // Trie un tableau du d√©but √† la fin
> // {1, 3, 5, 8}
> ```
> ```cpp
> std::vector<int> v{8, 5, 3, 1};
> std::sort(v.begin(), v.begin() + 2); // Trie les deux premiers √©l√©ments du tableau, c'est comme si on lui avait pass√© le tableau {8, 5}
> // {5, 8, 3, 1}
> ```
> ```cpp
> std::vector<int> v{8, 5, 3, 1};
> std::sort(v.begin() + 1, v.begin() + 3); // Trie le sous-tableau {5, 3}
> // {8, 3, 5, 1}
> ```
> Et vous pouvez aussi choisir selon quel ordre les √©l√©ments seront tri√©s :
> ```cpp
> std::vector<glm::vec3> v{/*...*/};
> std::sort(v.begin(), v.end(), [](glm::vec3 const& color1, glm::vec3 const& color2)
> {
>     return color1.r < color2.r; // Trie selon la composante rouge
> });
> ```
> ```cpp
> std::vector<glm::vec3> v{/*...*/};
> std::sort(v.begin(), v.end(), [](glm::vec3 const& color1, glm::vec3 const& color2)
> {
>     return brightness(color1) < brightness(color2); // Trie selon la luminosit√© des couleurs (NB : c'est √† vous de coder la fonction `brightness`)
> });
> ```
> On passe ce qu'on appelle une *lambda* en 3√®me argument : c'est une fonction d√©finie en plein milieu du code. Elle doit prendre en param√®tre deux √©l√©ments du tableau (deux `vec3` en l'occurrence) et retourner un bool√©en indiquant qui est le plus petit des deux √©l√©ments.

*Info:*
> Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Filtre de Kuwahara (effet peinture √† l'huile)

![](output/kuwahara.jpg)

Voici une vid√©o expliquant l'algorithme (La version simple de l'algo, qui est expliqu√©e entre 3:11 et 3:30, suffit largement. (Mais si vous voulez aller plus loin, vous √™tes les bienvenu.es bien s√ªr üòâ)) :
[![pixel sorting video](https://img.youtube.com/vi/LDhN-JK3U9g/0.jpg)](https://www.youtube.com/watch?v=LDhN-JK3U9g)

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê K-means : trouver les couleurs les plus pr√©sentes dans une image

| ![](images/photo.jpg)  | ![](output/k_means_2_colors.jpg) | ![](output/k_means_3_colors.jpg)  | ![](output/k_means_16_colors.jpg)  |
|---|----|----|----|
| Originale | 2 couleurs | 3 couleurs | 16 couleurs |

Trouvez les k couleurs les plus repr√©sentatives de l'image, puis assignez √† chaque pixel la couleur dont il est le plus proche parmi les k.

Voici une bonne vid√©o expliquant l'algorithme :

[![k-means video](https://img.youtube.com/vi/yR7k19YBqiw/0.jpg)](https://www.youtube.com/watch?v=yR7k19YBqiw)

*Info:*
> Vous pouvez utiliser `glm::distance(color1, color2)` pour obtenir la distance entre deux couleurs.

*Info:*
> Pour obtenir des nombres al√©atoires, includez le fichier `"random.hpp"` et utilisez soit `random_int(min, max)` soit `random_float(min, max)`. Si vous voulez que votre programme utilise les m√™mes nombres al√©atoires √† chaque fois que vous l'utilisez, vous pouvez d√©finir une seed avec `set_random_seed(0)` au d√©but de votre `main()` (vous pouvez passer n'importe quel nombre autre que 0, √ßa d√©finira quels seront les nombres g√©n√©r√©s par les fonctions random).

### ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Diamond Square

![](output/diamond_square_greyscale.png)

Algorithme de g√©n√©ration de height map, qui peut ensuite √™tre utilis√©e pour cr√©er des terrains proc√©duraux dans des jeux vid√©os par exemple.

Voici une bonne vid√©o expliquant l'algorithme :
[![diamond square video](https://img.youtube.com/vi/4GuAV1PnurU/0.jpg)](https://www.youtube.com/watch?v=4GuAV1PnurU)

Conseil: commencez par travailler sur une image toute petite (e.g. 17x17), afin de bien voir les pixels et ce qu'il se passe.

> Vous pouvez cr√©er une image noire avec
> ```cpp
> sil::Image image{17/*width*/, 17/*height*/};
> ```
> puis it√©rer sur les pixels pour les colorer.

#### ‚≠ê‚≠ê Colorer la height map

![](output/diamond_square_colored.png)

Appliquez un d√©grad√© en couleur en fonction du niveau de gris de la height map.
> Avec `glm::mix(color1, color2, pourcentage);` vous pouvez faire un m√©lange entre deux couleurs donn√©es.

<details><summary>Indice</summary>

Essayez par exemple de faire un d√©grad√© de bleu du sombre au clair quand le niveau de gris est entre 0 et 0.5, et un autre d√©grad√© entre du vert et du marron quand le niveau de gris est entre 0.5 et 1.
</details>

### Vous pouvez impl√©menter vos propres effets !